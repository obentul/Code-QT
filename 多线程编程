#1    ==========================================================================================

每个Qt程序都有一个主线程和一个主线程池。

可以通过globalInstance()函数来访问这个主线程，方法为 QThreadPool::globalInstance()，可见QthreadPool
类中有一个静态成员变量，即运行程序的主线程。

每一个QThread类都有一个start函数，这个函数接收一个 QRunable 实例，又QRunnable有run()虚函数，相当于是
线程函数体，当一个QThread实例调用其start函数的时候，就相当于把start函数的参数作为函数实例丢入线程中
运行


线程相关的类

QThreadPool   (线程池)
    |
QThread	      (线程)
    |
QRunnable     (线程需要的执行函数)


#2    ==========================================================================================


如上面所述，QThread是一个线程实例，这很好管理，但是QRunable是一个可执行函数实例，这个管理就必须
注意，因为它不是在编译时被放入.text区域的，不是始终静态存在的，而是一个“实例”，是存在于堆栈中的，
那么这个实例何时被销毁？如果QThread在使用QRunnable时，实例不存在了，会怎么样，该怎么安全地使用？

1）QRunnable实例是可被多个QThread使用的，这很好理解，就好像函数一样，可以被多个线程同时调用，但是
   注意！在函数设计时，需要考虑可重入性，也可以利用这点来实现多个线程同时操作共享资源。

2）QThread在使用QRunnable实例时，应当使用tryStart()来代替start()。

3）QRunnable有一个标志位是autoDelete，当所有使用本QRRunable的QThread都 exit 后，本QRunable将会
   被销毁，这个属性不是必须的，比如，如果我就是想注册一个函数，那就没必要频繁销毁和创建QRunable

4）可以设置线程池中所有线程的执行超时时间，如超时，则自动退出，此外还可以设置重新启动标志，当超时
   后可以立即重启。默认情况下，QThreadPool对各个线程的超时时间设置为负值，代表永不超时。
	注：超时时间对线程池中已经运行的线程不生效，只对尚未运行的生效。
	    好像不能对线程分开设置超时时间？

5）QThreadPool 对线程的管理 偏底层，如果对线程的功能特别了解，那么用起来很顺手。否则可以使用
   Qt Concurrent module 来更加易用地操作线程。
   (建议使用QThreadPool，后期特别了解后，可以使用Qt Concurrent module)

